#!/usr/bin/Rscript
##
## File:    plotCycleLengthDistributionsFromTablesMultiMethods.R
## Author:  Alex Stivala
## Created: Februrary 2023
##
## (based on plotCycleLengthDistributionsFromTables.R July 2019)
##
## Read tables generated by makeCycleLengthDistributionTables.sh
## and make boxplots for simulated networks with points/line for
## observed network on same plot for comparison.
##
## This script takes two pairs of tables (simulated and obseved)
## for two different methods (approximation/lower bound from 'atomic' cycle
## routine, and exact counting from filterGeodesicCycles.py for example)
## and plots both on same plot for comparison.
##
## Usage: Rscript plotCycleLengthDistributionFromTablesMultiMethods.R description table1.txt obs_table1.txt table2.txt obs_table2.txt method1_name method2_name
##
##    title       is text for plto title e.g. "ERGM" or "dk-series 2.5 k"
##    description is text description for labels e.g. "geodesic cycle"
##    table1.txt is output of makeAtomicCycleLengthDistributionTables.sh
##    obs_table1.txt is output of makeSingleNetworkAtomicCycleLengthDistributionTable.sh
##    table2.txt is output of makeGeodesicCycleLengthDistributionTables.sh
##    obs_table2.txt is output of makeSingleNetworkGeodesicCycleLengthDistributionTable.sh
##    method1_name is name of first method for labels
##    method2_name is name of second method for labels
##   
##  output files are built from basename of table.txt file as:
##        <tablename2>_lengthdist_multi.eps
##        <tablename2>_largest_multi.eps
##
##  WARNING: output files are overwritten
##
## Example:
## 
## Rscript ../../scripts/plotCycleLengthDistributionsFromTablesMultiMethods.R "dk-series 2.5k" 'geodesic cycle' dk25_atomiccycledisttable.txt greysanatomy_atomiccycletable.txt dk25_geodesiccycledisttable.txt greysanatomy_geodesiccycletable.txt "findAtomicCycles" "countGeodesicCycles"
##


library(ggplot2)
library(doBy)

###
### Main
###
args <- commandArgs(trailingOnly=TRUE)
if (length(args) != 8) {
  cat("Usage: Rscript plotCycleLengthDistributionsFromTablesMultiMethods.R description table1.txt obs_table1.txt table2.txt obs_table2.txt method1_name method2_name\n")
  quit(save="no")
}
title <- args[1]
descr <- args[2]
tablefilename1 <- args[3]
obs_tablefilename1 <- args[4]
tablefilename2 <- args[5]
obs_tablefilename2 <- args[6]
method1_name <- args[7]
method2_name <- args[8]

tablename <- sub("(.+)[.].+", "\\1", basename(tablefilename2))



ptheme <-  theme(legend.position = 'bottom')

##
## return name list of simulated data "datf" and observed data "obs_datf"
## data frames
##
build_data_frames <- function(tablefilename, obs_tablefilename, maxlen) {
  
  dat <- read.table(tablefilename, header=TRUE)
  obs_dat <- read.table(obs_tablefilename, header=TRUE)

  ## because CYPATH output for each network only has counts up to
  ## the longest cycle, but different simulated newtorks can have different
  ## length of longest cycles, we need to pad out entries for each simulated
  ## network with 0 counts from 1 more than the largest cycle in that network
  ## up to the largest cycle of any of the networks.
  ## More generally, findAtomicCycles only outputs actual cycles, and so
  ## the script makeAtomicCycleLengthDistributionTables.sh only has
  ## entries for cycles that occur (have frequency > 0). 
  ## So instead of just padding on end, we need to actually add 0 count
  ## rows for every length that does not occur in the data for each simulated
  ## network.
  ## There is probably an easier/better way of doing this without a loop in R
  ## but this works.

  stopifnot(max(dat$length, na.rm = TRUE) <= maxlen)
  stopifnot(max(obs_dat$length, na.rm = TRUE) <= maxlen)

  datf <-data.frame()
  for (i in unique(dat$sim)) {
    simi <- dat[which(dat$sim == i),]
    simi <- simi[which(!is.na(simi$length)),]
    stopifnot(length(simi$length) == length(unique(simi$length)))
    if (length(simi$length) < maxlen) {
      for (len in 1:maxlen) {
        if (sum(simi$length == len) == 0) {
          datf <- rbind(datf, data.frame(sim = i, length = len, count = 0))
        } else {
          datf <- rbind(datf, simi[which(simi$length == len),])
        }
      }
    } else {
      datf <- rbind(datf, simi)
    }
  }


  obs_datf <- data.frame()
  stopifnot(length(obs_dat$length) == length(unique(obs_dat$length)))
  if (length(obs_dat$length) < maxlen) {
    for (len in 1:maxlen) {
      if (sum(obs_dat$length == len) == 0) {
        obs_datf <- rbind(obs_datf, data.frame(length = len, count = 0))
      } else {
        obs_datf <- rbind(obs_datf, obs_dat[which(obs_dat$length == len),])
      }
    }
  } else {
    obs_datf <- obs_dat
  }


  ## remove entries where length <=2 as never cycles of length 1 or 2
  stopifnot(sum(datf[which(datf$length <= 2),'count']) == 0)
  stopifnot(sum(obs_datf[which(obs_datf$length <= 2),'count']) == 0)
  datf <- datf[which(datf$length > 2),]
  obs_datf <- obs_datf[which(obs_datf$length > 2),]

  datf$length <- as.factor(datf$length)
  obs_datf$length <- as.factor(obs_datf$length)

  return(list (datf = datf, obs_datf = obs_datf))
}


## first get maximum cycle length in any data so data frames
## can be built of same size
dat1 <- read.table(tablefilename1, header=TRUE)
obs_dat1 <- read.table(obs_tablefilename1, header=TRUE)
dat2 <- read.table(tablefilename2, header=TRUE)
obs_dat2 <- read.table(obs_tablefilename2, header=TRUE)
maxlen <- max(dat1$length, obs_dat1$length,
              dat2$length, obs_dat2$length, na.rm = TRUE)
cat('maxlen = ', maxlen, '\n')

dfs1 <- build_data_frames(tablefilename1, obs_tablefilename1, maxlen)
dfs2 <- build_data_frames(tablefilename2, obs_tablefilename2, maxlen)


dfs1$datf$method <- method1_name
dfs1$obs_datf$method <- method1_name
dfs2$datf$method <- method2_name
dfs2$obs_datf$method <- method2_name

datf <- rbind(dfs1$datf, dfs2$datf)
obs_datf <- rbind(dfs1$obs_datf, dfs2$obs_datf)


p <- ggplot(datf, aes(x = length, y = count, fill = method))
p <- p + geom_boxplot()
p <- p + ggtitle(title)
p <- p + xlab(paste('Length of', descr))
p <- p + ptheme + ylab('Count')
p <- p + theme(axis.text = element_text(size = 20))
p <- p + theme(axis.title = element_text(size = 20))
p <- p + theme(plot.title = element_text(size = 20))
p <- p + theme(legend.title = element_text(size=20))
p <- p + theme(legend.text = element_text(size=20))
dw <- 0.1 # position_dodge width for points and lines
p <- p + geom_point(data=obs_datf, aes(x = length, y = count, group = method), 
                    shape = 23,size=4, position = position_dodge(width=dw))
p <- p + geom_line(data=obs_datf, aes(x = length, y = count, group = method, colour = method), position = position_dodge(width=dw))

outputepsfilename <- paste(tablename, '_lengthdist_multi.eps', sep='')
cat('Writing to ', outputepsfilename, '\n')
postscript(outputepsfilename, onefile=FALSE, paper="special", width=9, height=6)
print(p)
dev.off()

dat1$method <- method1_name
dat2$method <- method2_name
maxlendf1 <- summaryBy(length ~ sim + method, data = dat1, FUN = max)
maxlendf2 <- summaryBy(length ~ sim + method, data = dat2, FUN = max)
maxlendf <- rbind(maxlendf1, maxlendf2)
# replace NA max length with 0 for simulated newtorks with no cycles
if (any(is.na(maxlendf$length.max))) {
    maxlendf[which(is.na(maxlendf$length.max)),]$length.max <- 0
}
obs_maxlendf1 <- data.frame(maxlen = max(obs_dat1$length), method = method1_name)
obs_maxlendf2 <- data.frame(maxlen = max(obs_dat2$length), method = method2_name)
obs_maxlendf <- rbind(obs_maxlendf1, obs_maxlendf2)
#xfact <- factor(paste('Max', descr, 'length'))
p <- ggplot(maxlendf, aes(x = method, y = length.max))
p <- p + geom_boxplot()
p <- p + ggtitle(title)
p <- p + ylim(0, maxlen)
p <- p + xlab(paste('Max', descr, 'length'))
p <- p + theme(axis.text = element_text(size = 20))
p <- p + theme(axis.title = element_text(size = 20))
p <- p + theme(plot.title = element_text(size = 20))
p <- p + theme(legend.title = element_text(size=20))
p <- p + theme(legend.text = element_text(size=20))
p <- p + ptheme + ylab(paste('Length of', descr))
p <- p + geom_point(data = obs_maxlendf, aes(x = method, y = maxlen), colour = 'red', shape = 23, size = 4)

outputepsfilename <- paste(tablename, '_largest_multi.eps', sep='')
cat('Writing to ', outputepsfilename, '\n')
postscript(outputepsfilename, onefile=FALSE, paper="special", width=9, height=6)
print(p)
dev.off()


