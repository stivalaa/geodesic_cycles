#!/usr/bin/Rscript
##
## File:    plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethods.R
## Author:  Alex Stivala
## Created: February 2023
##
## (based on plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethods.R 
##  June 2020)
##
## Read tables generated by makeCycleLengthDistributinoTables.sh and
## make boxplots for maximum cycle length distrubutions for
## simulated networks with points/line for observed network on same
## plot for comparison, for all dk-series models and and ERGM model on
## the same plot.
##
## This script takes two pairs of tables (simulated and obseved)
## for two different methods (approximation/lower bound from 'atomic' cycle
## routine, and exact counting from filterGeodesicCycles.py for example)
## and plots both on same plot for comparison.
##
## Usage: Rscript plotCbominedMaxCycleLengthDistributionFromTablesMultiMethods.R description ergmtables_glob1 dktables_glob1 obs_table1.txt ermgtables_glob2 dktables_glob2 obs_table2.txt method1_name method2_name  output_filename.eps
##
##    description    is text description for labels e.g. "geodesic cycle"
##    ergmtables_glob1 is sh glob for cycle length distributions for ERGM models
##                      as produced e.g. by output of
##                      makeAtomicCycleLengthDistributionTables.sh
##                      e.g. "model?_atomiccycledisttable.txt". NOTE that
##                      the "model*_" prefix is required to get the ERGM
##                      label, for method 1.
##    dktables_glob2  is shell glob for dk-series tables each of which is
##                      output of e.g. makeAtcomiCycleLengthDistributionTables.sh,
##                      for method 2.
##                      e.g. "dk*_atomiccycledisttable.txt" NOTE that
##                      the "dk*_" prefix is required to get the dk-series
##                      label e.g. dk21
##    obs_table1.txt is cycle length distribution of observed network 
##                     for method 1, as e.g.   output of
##                     makeSingleNetworkAtomicCycleLengthDistributionTable.sh
##    ergmtables_glob2 is sh glob for cycle length distributions for ERGM models
##                      as produced e.g. by output of
##                      makeGeodesicCycleLengthDistributionTables.sh
##                      e.g. "model?_atomiccycledisttable.txt". NOTE that
##                      the "model*_" prefix is required to get the ERGM
##                      label, for method 2.
##    dktables_glob2  is shell glob for dk-series tables each of which is
##                      output of e.g. makeAtcomiCycleLengthDistributionTables.sh,
##                      for method 2.
##                      e.g. "dk*_atomiccycledisttable.txt" NOTE that
##                      the "dk*_" prefix is required to get the dk-series
##                      label e.g. dk22
##    obs_table2.txt is cycle length distribution of observed network 
##                     for method 2, as e.g.   output of
##                     makeSingleNetworkGeodesicCycleLengthDistributionTable.sh
##    method1_name is name of first method for labels
##    method2_name is name of second method for labels
##    output_Filename.eps is output EPS filename.
##                         WARNING: output files are overwritten
##
## Example:
##
## Rscript ../../scripts/plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethods.R 'geodesic cycle' ../statnet_estimations/model5_atomiccycledisttable.txt "dk*_atomiccycledisttable.txt" greysanatomy_atomiccycletable.txt ../statnet_estimations/model5_geodesiccycledisttable.txt "dk*_geodesiccycledisttable.txt" greysanatomy_geodesiccycletable.txt "findAtomicCycles" "countGeodesicCycles" greysanatomy_combined_max_geodesic_multimodels.eps 
##


library(ggplot2)
library(doBy)

###
### Main
###
args <- commandArgs(trailingOnly=TRUE)
if (length(args) != 10) {
  cat("Usage: Rscript plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethods.R descr ergmtables_glob1 dktables_glob1 obs_table1.txt ergmtables_glob2 dktabes_glob2 obs_table2.txt method1_name method2_name output.eps\n")
  quit(save="no")
}
descr              <- args[1]
ergmtables_glob1   <- args[2]
dk_table_glob1     <- args[3]
obs_tablefilename1 <- args[4]
ergmtables_glob2   <- args[5]
dk_table_glob2     <- args[6]
obs_tablefilename2 <- args[7]
method1_name       <- args[8]
method2_name       <- args[9]
outputepsfilename  <- args[10]



ptheme <-  theme(legend.position = 'bottom')



read_ergm_files <- function(ergmtables_glob) {
  ergm_files <- Sys.glob(ergmtables_glob)
  if (length(ergm_files) == 0) {
    cat('No ERGM data\n')
    ergm_dat <- data.frame()
  } else {
    cat('Reading ERGM data from ', ergm_files, '\n')
    ergm_dat <- data.frame()
    for (ergmfile in ergm_files) {
      if (length(ergm_files) == 1) {
        ergmname <- 'ERGM'
      } else {
        ergmname <- sub("model([0-9]+)_.+", "ERGM \\1", basename(ergmfile))
      }
      print(ergmname)
      ergmtab <- read.table(ergmfile, header=TRUE)
      ergmtab$model = ergmname
      ergm_dat <- rbind(ergm_dat, ergmtab)
    }
  }
  return(ergm_dat)
}


read_dk_files <- function(dk_table_glob) {
  dk_files <- Sys.glob(dk_table_glob)
  cat('Reading dk-series data from ',dk_files,'\n')
  dat <- data.frame()
  for (dkfile in dk_files) {
    dkname <- sub("(dk[0-9]+)_.+", "\\1", basename(dkfile))
    print(dkname)
    if (dkname == "dk0") {
      dkname <- "dk 0 k"
    } else if (dkname == "dk1") {
      dkname <- "dk 1 k"
    } else if (dkname == "dk2") {
      dkname <- "dk 2 k"
    } else if (dkname == "dk21") {
      dkname <- "dk 2.1 k"
    } else if (dkname == "dk25") {
      dkname <- "dk 2.5 k"
    }
  
    dktab <- read.table(dkfile, header=TRUE)
    if (nrow(dktab) > 0) {
      dktab$model <- dkname
    }
    dat <- rbind(dat, dktab)
  }
  return(dat)
}
 
obs1_dat <- read.table(obs_tablefilename1, header=TRUE)
obs2_dat <- read.table(obs_tablefilename2, header=TRUE)
obs1_dat$method <- method1_name
obs2_dat$method <- method2_name
obs_dat <- rbind(obs1_dat, obs2_dat)

dat1 <- rbind(read_ergm_files(ergmtables_glob1), 
              read_dk_files(dk_table_glob1))
dat2 <- rbind(read_ergm_files(ergmtables_glob2), 
              read_dk_files(dk_table_glob2))

dat1$method <- method1_name
dat2$method <- method2_name

maxlen <- max(dat1$length, obs1_dat$length,
              dat2$length, obs2_dat$length, na.rm = TRUE)
cat('maxlen = ', maxlen, '\n')

lendf <- rbind(dat1, dat2)
lendf$model <- factor(lendf$model)

print(lendf)#XXX
maxlendf <- summaryBy(length ~ sim + method + model, data = lendf, FUN = max)
print(maxlendf)#XXX
# replace NA max length with 0 for simulated newtorks with no cycles
if (any(is.na(maxlendf$length.max))) {
    maxlendf[which(is.na(maxlendf$length.max)),]$length.max <- 0
}
obs_dat$method <- factor(obs_dat$method)
print(obs_dat)#XXX
obs_maxlendf <- summaryBy(length ~ method, data = obs_dat, FUN = max)
print(obs_maxlendf)#XXX
stopifnot(all(obs_maxlendf$count > 0))
p <- ggplot(maxlendf, aes(x = model, y = length.max, fill = method))
p <- p + geom_boxplot()
p <- p + ptheme
p <- p + theme(axis.text = element_text(size = 12))
p <- p + theme(axis.title = element_text(size = 12))
p <- p + theme(legend.title = element_text(size=12))
p <- p + theme(legend.text = element_text(size=12))
p <- p + ylim(0, maxlen)
p <- p + theme(axis.text.x = element_text(colour = 'black'))
p <- p + ptheme + xlab('Simulation model') + ylab(paste('Length of largest', descr))
p <- p + geom_hline(data = obs_maxlendf, aes(yintercept = length.max, colour = method,linetype = method))

cat('Writing to ', outputepsfilename, '\n')
postscript(outputepsfilename, onefile=FALSE, paper="special", width=9, height=6)
print(p)
dev.off()


