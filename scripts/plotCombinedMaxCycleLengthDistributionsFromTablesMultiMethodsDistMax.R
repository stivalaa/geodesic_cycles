#!/usr/bin/Rscript
##
## File:    plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethodsDistMax.R
## Author:  Alex Stivala
## Created: March 2023
##
## (based on plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethods.R 
##  Feburary 2023)
##
## Read tables generated by makeCycleLengthDistributinoTables.sh
## (for cycle length distribution) and longestIsometricCycle.py
## (for maximum cycle length only) and
## make boxplots for maximum cycle length distrubutions for
## simulated networks with points/line for observed network on same
## plot for comparison, for all dk-series models and and ERGM model on
## the same plot.
##
## Usage: Rscript plotCombinedMaxCycleLengthDistributionFromTablesMultiMethodsDistMax.R description ergmtables_glob1 dktables_glob1 obs_table1.txt ermgtables_glob2 dktables_glob2 obs_table2.txt method1_name method2_name  output_filename.eps
##
##    description    is text description for labels e.g. "geodesic cycle"
##    ergmtables_glob1 is sh glob for cycle length distributions for ERGM models
##                      as produced e.g. by output of
##                      makeAtomicCycleLengthDistributionTables.sh
##                      e.g. "model?_atomiccycledisttable.txt". NOTE that
##                      the "model*_" prefix is required to get the ERGM
##                      label, for method 1.
##    dktables_glob2  is shell glob for dk-series tables each of which is
##                      output of e.g. makeAtcomiCycleLengthDistributionTables.sh,
##                      for method 2.
##                      e.g. "dk*_atomiccycledisttable.txt" NOTE that
##                      the "dk*_" prefix is required to get the dk-series
##                      label e.g. dk21
##    obs_table1.txt is cycle length distribution of observed network 
##                     for method 1, as e.g.   output of
##                     makeSingleNetworkAtomicCycleLengthDistributionTable.sh
##    ergmtables_glob2 is sh glob for max cycle length for ERGM models
##                      as produced e.g. by output of
##                      makeLongestISometricCycleLengthTables.sh
##                      e.g. "model?_longest_isometric_cycle.txt". NOTE that
##                      the "model*_" prefix is required to get the ERGM
##                      label, for method 2.
##    dktables_glob2  is shell glob for dk-series tables each of which is
##                      output of e.g.
##                       makeLongestISometricCycleLengthTables.sh.sh,
##                       for method 2.
##                      e.g. "dk*_longest_isometric_cycle.txt" NOTE that
##                      the "dk*_" prefix is required to get the dk-series
##                      label e.g. dk22
##    obs_table2.txt is cycle length distribution of observed network 
##                     for method 2, as e.g.   output of
##                     longestIsometricCycle.y
##    method1_name is name of first method for labels
##    method2_name is name of second method for labels
##    output_Filename.eps is output EPS filename.
##                         WARNING: output files are overwritten
##
##
## The tables for method1 have a "length" column for length of each cycle
## (giving full cycle length distribution, they also have a "count" field
## for each value of length), while the tables for method2 have a "maxlen"
## column, they have only the largest cycle length.
##
## Example:
##
## Rscript ../../scripts/plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethodsDistMax.R 'geodesic cycle' model1_geodesiccycledisttable.txt "dk*_geodesiccycledisttable.txt" patricia1990_geodesiccycletable.txt  model1_longest_isometric_cycle.txt "dk*_longest_isometric_cycle.txt" patricia1990_longest_isometric_cycle.txt "countGeodesicCycles" "longestIsometricCycle" patricia1990_combined_max_geodesic_multimodels_distmax.eps
##


library(ggplot2)
library(doBy)

###
### Main
###
args <- commandArgs(trailingOnly=TRUE)
if (length(args) != 10) {
  cat("Usage: Rscript plotCombinedMaxCycleLengthDistributionsFromTablesMultiMethodsDistMax.R descr ergmtables_glob1 dktables_glob1 obs_table1.txt ergmtables_glob2 dktabes_glob2 obs_table2.txt method1_name method2_name output.eps\n")
  quit(save="no")
}
descr              <- args[1]
ergmtables_glob1   <- args[2]
dk_table_glob1     <- args[3]
obs_tablefilename1 <- args[4]
ergmtables_glob2   <- args[5]
dk_table_glob2     <- args[6]
obs_tablefilename2 <- args[7]
method1_name       <- args[8]
method2_name       <- args[9]
outputepsfilename  <- args[10]



ptheme <-  theme(legend.position = 'bottom')



read_ergm_files <- function(ergmtables_glob) {
  ergm_files <- Sys.glob(ergmtables_glob)
  if (length(ergm_files) == 0) {
    cat('No ERGM data\n')
    ergm_dat <- data.frame()
  } else {
    cat('Reading ERGM data from ', ergm_files, '\n')
    ergm_dat <- data.frame()
    for (ergmfile in ergm_files) {
      if (length(ergm_files) == 1) {
        ergmname <- 'ERGM'
      } else {
        ergmname <- sub("model([0-9]+)_.+", "ERGM \\1", basename(ergmfile))
      }
      print(ergmname)
      ergmtab <- read.table(ergmfile, header=TRUE)
      ergmtab$model = ergmname
      ergm_dat <- rbind(ergm_dat, ergmtab)
    }
  }
  return(ergm_dat)
}


read_dk_files <- function(dk_table_glob) {
  dk_files <- Sys.glob(dk_table_glob)
  cat('Reading dk-series data from ',dk_files,'\n')
  dat <- data.frame()
  for (dkfile in dk_files) {
    dkname <- sub("(dk[0-9]+)_.+", "\\1", basename(dkfile))
    print(dkname)
    if (dkname == "dk0") {
      dkname <- "dk 0 k"
    } else if (dkname == "dk1") {
      dkname <- "dk 1 k"
    } else if (dkname == "dk2") {
      dkname <- "dk 2 k"
    } else if (dkname == "dk21") {
      dkname <- "dk 2.1 k"
    } else if (dkname == "dk25") {
      dkname <- "dk 2.5 k"
    }
  
    dktab <- read.table(dkfile, header=TRUE)
    if (nrow(dktab) > 0) {
      dktab$model <- dkname
    }
    dat <- rbind(dat, dktab)
  }
  return(dat)
}
 
obs1_dat <- read.table(obs_tablefilename1, header=TRUE)
obs2_dat <- read.table(obs_tablefilename2, header=TRUE)
obs1_dat$method <- method1_name
obs2_dat$method <- method2_name

dat1 <- rbind(read_ergm_files(ergmtables_glob1), 
              read_dk_files(dk_table_glob1))
dat2 <- rbind(read_ergm_files(ergmtables_glob2), 
              read_dk_files(dk_table_glob2))

dat1$method <- method1_name
dat2$method <- method2_name

maxlendf <- summaryBy(length ~ sim + method + model, data = dat1, FUN = max)
# replace NA max length with 0 for simulated newtorks with no cycles
if (any(is.na(maxlendf$length.max))) {
    maxlendf[which(is.na(maxlendf$length.max)),]$length.max <- 0
}

maxlen <- max(dat1$length, obs1_dat$length,
              dat2$maxlen, obs2_dat$maxlen, na.rm = TRUE)
cat('maxlen = ', maxlen, '\n')

# rename summary column to match other data frame
names(maxlendf)[names(maxlendf) == "length.max"] <- "maxlen"
maxlendf <- rbind(maxlendf[order(names(maxlendf))], dat2[order(names(dat2))])
maxlendf$model <- factor(maxlendf$model)

obs_maxlendf <- summaryBy(length ~ method, data = obs1_dat, FUN = max)
names(obs_maxlendf)[names(obs_maxlendf) == "length.max"] <- "maxlen"
obs_maxlendf <- rbind(obs_maxlendf[order(names(obs_maxlendf))], obs2_dat[order(names(obs2_dat))])
obs_maxlendf$method <- factor(obs_maxlendf$method)
p <- ggplot(maxlendf, aes(x = model, y = maxlen, fill = method))
p <- p + geom_boxplot()
p <- p + ptheme
p <- p + theme(axis.text = element_text(size = 12))
p <- p + theme(axis.title = element_text(size = 12))
p <- p + theme(legend.title = element_text(size=12))
p <- p + theme(legend.text = element_text(size=12))
p <- p + ylim(0, maxlen)
p <- p + theme(axis.text.x = element_text(colour = 'black'))
p <- p + ptheme + xlab('Simulation model') + ylab(paste('Length of largest', descr))
p <- p + geom_hline(data = obs_maxlendf, aes(yintercept = maxlen, colour = method,linetype = method))

cat('Writing to ', outputepsfilename, '\n')
postscript(outputepsfilename, onefile=FALSE, paper="special", width=9, height=6)
print(p)
dev.off()


